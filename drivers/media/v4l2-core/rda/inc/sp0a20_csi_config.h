#ifndef _SP0A20_CFG_H_
#define _SP0A20_CFG_H_

#include "rda_sensor.h"
#include <linux/delay.h>

#ifdef BIT
#undef BIT
#endif
#define BIT	8

static const struct sensor_reg exp_sp0a20[][3] =
{
	{{0xfd,0x01,BIT,0},{0x24,0x10,BIT,0},{0x01,0x01,BIT,0}},
	{{0xfd,0x01,BIT,0},{0x24,0x14,BIT,0},{0x01,0x01,BIT,0}},
	{{0xfd,0x01,BIT,0},{0x24,0x18,BIT,0},{0x01,0x01,BIT,0}},
	{{0xfd,0x01,BIT,0},{0x24,0x1c,BIT,0},{0x01,0x01,BIT,0}},
	{{0xfd,0x01,BIT,0},{0x24,0x20,BIT,0},{0x01,0x01,BIT,0}},
	{{0xfd,0x01,BIT,0},{0x24,0x28,BIT,0},{0x01,0x01,BIT,0}},
	{{0xfd,0x01,BIT,0},{0x24,0x30,BIT,0},{0x01,0x01,BIT,0}},
	{{0xfd,0x01,BIT,0},{0x24,0x40,BIT,0},{0x01,0x01,BIT,0}},
};


static const struct sensor_reg awb_sp0a20[][6] =
{
	{{0xfd,0x02,BIT,0},{0xfd,0x00,BIT,0},{0xfd,0x00,BIT,0},{0xfd,0x00,BIT,0},{0xfd,0x00,BIT,0},{0xfd,0x00,BIT,0}},//OFF
	{{0xfd,0x02,BIT,0},{0x26,0xc8,BIT,0},{0x27,0xb6,BIT,0},{0xfd,0x01,BIT,0},{0x32,0x15,BIT,0},{0xfd,0x00,BIT,0}},//AUTO
	{{0xfd,0x01,BIT,0},{0x32,0x05,BIT,0},{0xfd,0x02,BIT,0},{0x26,0xaa,BIT,0},{0x27,0xce,BIT,0},{0xfd,0x00,BIT,0}},//INCANDESCENT
	{{0xfd,0x01,BIT,0},{0x32,0x05,BIT,0},{0xfd,0x02,BIT,0},{0x26,0x91,BIT,0},{0x27,0xc8,BIT,0},{0xfd,0x00,BIT,0}},//FLUORESCENT
	{{0xfd,0x01,BIT,0},{0x32,0x05,BIT,0},{0xfd,0x02,BIT,0},{0x26,0x75,BIT,0},{0x27,0xe2,BIT,0},{0xfd,0x00,BIT,0}},//TUNGSTEN
	{{0xfd,0x01,BIT,0},{0x32,0x05,BIT,0},{0xfd,0x02,BIT,0},{0x26,0xc8,BIT,0},{0x27,0x89,BIT,0},{0xfd,0x00,BIT,0}},//DAYLIGHT
	{{0xfd,0x01,BIT,0},{0x32,0x05,BIT,0},{0xfd,0x02,BIT,0},{0x26,0xdc,BIT,0},{0x27,0x75,BIT,0},{0xfd,0x00,BIT,0}},//CLOUD
};

// use this for 640x480 (VGA) capture
static const struct sensor_reg vga_sp0a20[] =
{
	{0xfd,0x01,BIT,0},
	{0xfd,0x00,BIT,0},
};

// use this for 320x240 (QVGA) capture
static const struct sensor_reg qvga_sp0a20[] =
{
	{0xfd,0x01,BIT,0},
	{0xfd,0x00,BIT,0},
};


// use this for 160x120 (QQVGA) capture
static const struct sensor_reg qqvga_sp0a20[] =
{
	{0xfd,0x01,BIT,0},
};

// use this for 176x144 (QCIF) capture
static const struct sensor_reg qcif_sp0a20[] =
{
        {0xfd,0x00,BIT,0},
        {0xfd,0x01,BIT,0},
};

// use this for init sensor
static const struct sensor_reg init_sp0a20[] =
{


  {0xfd,0x00,BIT,0},//
  {0xfd,0x01,BIT,0},//
  {0x36,0x02,BIT,0},//
  {0xfd,0x00,BIT,0},//;
  {0x0c,0x00,BIT,0},//
  {0x92,0x70,BIT,0},// ;before LP11 keep LP00
  {0x1b,0x27,BIT,0},//;
  {0x12,0x02,BIT,0},//;
  {0x13,0x2f,BIT,0},//;
  {0x6d,0x32,BIT,0},//;
  {0x6c,0x32,BIT,0},//;
  {0x6f,0x33,BIT,0},//;
  {0x6e,0x34,BIT,0},//;
  {0x99,0x04,BIT,0},// ;open driver
  {0x16,0x38,BIT,0},//;
  {0x17,0x38,BIT,0},//;
  {0x70,0x3a,BIT,0},//;
  {0x14,0x02,BIT,0},//;
  {0x15,0x20,BIT,0},//;
  {0x71,0x23,BIT,0},//;
  {0x69,0x25,BIT,0},//;
  {0x6a,0x1a,BIT,0},//;
  {0x72,0x1c,BIT,0},//;
  {0x75,0x1e,BIT,0},//;
  {0x73,0x3c,BIT,0},//;
  {0x74,0x21,BIT,0},//;
  {0x79,0x00,BIT,0},//;
  {0x77,0x10,BIT,0},//;
  {0x1a,0x4d,BIT,0},//;
  {0x1c,0x07,BIT,0},//;
  {0x1e,0x15,BIT,0},//;
  {0x21,0x08,BIT,0},//;
  {0x22,0x28,BIT,0},//;
  {0x26,0x66,BIT,0},//;
  {0x28,0x0b,BIT,0},//;
  {0x37,0x4a,BIT,0},//;
  {0xfd,0x02,BIT,0},//
  {0x01,0x80,BIT,0},//;
  {0x52,0x10,BIT,0},//;
  {0x54,0x00,BIT,0},//;
  {0xfd,0x01,BIT,0},//;blacklevel
  {0x41,0x00,BIT,0},//;
  {0x42,0x00,BIT,0},//;
  {0x43,0x00,BIT,0},//;
  {0x44,0x00,BIT,0},//;
  {0xfd,0x00,BIT,0},//
  {0x03,0x02,BIT,0},//
  {0x04,0x58,BIT,0},//
  {0x05,0x00,BIT,0},//
  {0x06,0x00,BIT,0},//
  {0x07,0x00,BIT,0},//
  {0x08,0x00,BIT,0},//
  {0x09,0x01,BIT,0},//
  {0x0a,0x64,BIT,0},//
  {0xfd,0x01,BIT,0},//
  {0xf0,0x00,BIT,0},//
  {0xf7,0x64,BIT,0},//
  {0x02,0x0c,BIT,0},//
  {0x03,0x01,BIT,0},//
  {0x06,0x64,BIT,0},//
  {0x07,0x00,BIT,0},//
  {0x08,0x01,BIT,0},//
  {0x09,0x00,BIT,0},//
  {0xfd,0x02,BIT,0},//
  {0xbe,0xb0,BIT,0},//
  {0xbf,0x04,BIT,0},//
  {0xd0,0xb0,BIT,0},//
  {0xd1,0x04,BIT,0},//
  {0xfd,0x01,BIT,0},//
  {0x5a,0x40,BIT,0},//;dp rpc   
  {0xfd,0x02,BIT,0},// 
  {0xbc,0x70,BIT,0},//;rpc_heq_low
  {0xbd,0x50,BIT,0},//;rpc_heq_dummy
  {0xb8,0x68,BIT,0},//;mean_normal_dummy
  {0xb9,0x80,BIT,0},//;mean_dummy_normal
  {0xba,0x30,BIT,0},//;mean_dummy_low
  {0xbb,0x45,BIT,0},//;mean low_dummy
  {0xfd,0x01,BIT,0},//;rpc                   
  {0xe0,0x50,BIT,0},//;0x4c;rpc_1base_max
  {0xe1,0x3e,BIT,0},//;0x3c;rpc_2base_max
  {0xe2,0x36,BIT,0},//;0x34;rpc_3base_max
  {0xe3,0x30,BIT,0},//;0x2e;rpc_4base_max
  {0xe4,0x30,BIT,0},//;0x2e;rpc_5base_max
  {0xe5,0x2e,BIT,0},//;0x2c;rpc_6base_max
  {0xe6,0x2e,BIT,0},//;0x2c;rpc_7base_max
  {0xe7,0x2c,BIT,0},//;0x2a;rpc_8base_max
  {0xe8,0x2c,BIT,0},//;0x2a;rpc_9base_max
  {0xe9,0x2c,BIT,0},//;0x2a;rpc_10base_max
  {0xea,0x2a,BIT,0},//;0x28;rpc_11base_max
  {0xf3,0x2a,BIT,0},//;0x28;rpc_12base_max
  {0xf4,0x2a,BIT,0},//;0x28;rpc_13base_max
  {0xfd,0x01,BIT,0},//
  {0x04,0xa0,BIT,0},//;rpc_max_indr
  {0x05,0x2a,BIT,0},//;rpc_min_indr 
  {0x0a,0xa0,BIT,0},//;rpc_max_outdr
  {0x0b,0x2a,BIT,0},//;rpc_min_outdr
  {0xfd,0x01,BIT,0},//
  {0xeb,0x78,BIT,0},//;target indr
  {0xec,0x78,BIT,0},//;target outdr
  {0xed,0x05,BIT,0},//;lock range
  {0xee,0x0c,BIT,0},//;hold range
  {0xfd,0x01,BIT,0},//;??
  {0xf2,0x4d,BIT,0},//;
  {0xfd,0x02,BIT,0},//;
  {0x5b,0x05,BIT,0},//;dp status
  {0x5c,0xa0,BIT,0},//;
  {0xfd,0x01,BIT,0},//
  {0x26,0x80,BIT,0},//;
  {0x27,0x4f,BIT,0},//;
  {0x28,0x00,BIT,0},//;
  {0x29,0x20,BIT,0},//;
  {0x2a,0x00,BIT,0},//;
  {0x2b,0x03,BIT,0},//;
  {0x2c,0x00,BIT,0},//;
  {0x2d,0x20,BIT,0},//;
  {0x30,0x00,BIT,0},//;
  {0x31,0x00,BIT,0},//;
  {0xfd,0x01,BIT,0},//;lsc 1
  {0xa1,0x31,BIT,0},//;2d;2c;r
  {0xa2,0x33,BIT,0},//;2f;2c;
  {0xa3,0x2f,BIT,0},//;2d;2c;
  {0xa4,0x2f,BIT,0},//;2d;2c;
  {0xa5,0x26,BIT,0},//;23;2c;g
  {0xa6,0x25,BIT,0},//;21;2c;
  {0xa7,0x28,BIT,0},//;26;2c;
  {0xa8,0x28,BIT,0},//;26;2c;
  {0xa9,0x23,BIT,0},//;21;2c;b
  {0xaa,0x23,BIT,0},//;21;2c;
  {0xab,0x24,BIT,0},//;26;2c;
  {0xac,0x24,BIT,0},//;26;2c;
  {0xad,0x0e,BIT,0},//;10;12;r
  {0xae,0x0e,BIT,0},//;10;12;
  {0xaf,0x0e,BIT,0},//;0e;12;
  {0xb0,0x0e,BIT,0},//;0e;12;
  {0xb1,0x00,BIT,0},//;00;00;g
  {0xb2,0x00,BIT,0},//;00;00;
  {0xb3,0x00,BIT,0},//;00;00;
  {0xb4,0x00,BIT,0},//;00;00;
  {0xb5,0x00,BIT,0},//;00;00;b
  {0xb6,0x00,BIT,0},//;00;00;
  {0xb7,0x00,BIT,0},//;00;00;
  {0xb8,0x00,BIT,0},//;00;00;
  {0xfd,0x02,BIT,0},//;skin detect
  {0x08,0x00,BIT,0},//;
  {0x09,0x06,BIT,0},//;
  {0x1d,0x03,BIT,0},//;
  {0x1f,0x05,BIT,0},//;
  {0xfd,0x01,BIT,0},//;awb
  {0x32,0x00,BIT,0},//;
  {0xfd,0x02,BIT,0},//;
  {0x26,0xb8,BIT,0},//;
  {0x27,0xa2,BIT,0},//;
  {0xfd,0x00,BIT,0},//
  {0xe7,0x03,BIT,0},//
  {0xe7,0x00,BIT,0},//
  {0xfd,0x02,BIT,0},//
  {0x1b,0x80,BIT,0},//;
  {0x1a,0x80,BIT,0},//;
  {0x18,0x27,BIT,0},//;
  {0x19,0x26,BIT,0},//;
  {0x2a,0x01,BIT,0},//;
  {0x2b,0x08,BIT,0},//;
  {0x28,0xf8,BIT,0},//;
  {0x29,0x08,BIT,0},//;
  {0x66,0x43,BIT,0},//; 4e    d65 10
  {0x67,0x5e,BIT,0},//; 6e
  {0x68,0xd2,BIT,0},//; d2
  {0x69,0xee,BIT,0},//; ee
  {0x6a,0xa5,BIT,0},//;
  {0x7c,0x34,BIT,0},//
  {0x7d,0x58,BIT,0},//;
  {0x7e,0xfb,BIT,0},//;
  {0x7f,0x1d,BIT,0},//;
  {0x80,0xa6,BIT,0},//;
  {0x70,0x20,BIT,0},//
  {0x71,0x41,BIT,0},//;
  {0x72,0x28,BIT,0},//;
  {0x73,0x47,BIT,0},//;
  {0x74,0xaa,BIT,0},//;
  {0x6b,0x00,BIT,0},//;tl84  13
  {0x6c,0x20,BIT,0},//;
  {0x6d,0x30,BIT,0},//;
  {0x6e,0x50,BIT,0},//;
  {0x6f,0xaa,BIT,0},//;
  {0x61,0xf2,BIT,0},//;f    14
  {0x62,0x13,BIT,0},//;
  {0x63,0x50,BIT,0},//;
  {0x64,0x70,BIT,0},//;
  {0x65,0x6a,BIT,0},//; 
  {0x75,0x80,BIT,0},//;
  {0x76,0x09,BIT,0},//;
  {0x77,0x02,BIT,0},//;
  {0x24,0x25,BIT,0},//;
  {0x0e,0x16,BIT,0},//;
  {0x3b,0x09,BIT,0},//;
  {0xfd,0x02,BIT,0},//;sharp
  {0xde,0x0f,BIT,0},//;
  {0xd7,0x08,BIT,0},//; ;sharp_flat_thr 轮廓判断
  {0xd8,0x08,BIT,0},//;
  {0xd9,0x10,BIT,0},//;
  {0xda,0x14,BIT,0},//;
  {0xe8,0x20,BIT,0},//;sharp_fac_pos 轮廓强度
  {0xe9,0x20,BIT,0},//;
  {0xea,0x20,BIT,0},//;
  {0xeb,0x20,BIT,0},//;
  {0xec,0x20,BIT,0},//;sharp_fac_neg
  {0xed,0x20,BIT,0},//;
  {0xee,0x20,BIT,0},//;
  {0xef,0x20,BIT,0},//;  
  {0xd3,0x20,BIT,0},//; sharp_ofst_pos
  {0xd4,0x48,BIT,0},//; sharp_ofst_neg
  {0xd5,0x20,BIT,0},//; sharp_ofst_min
  {0xd6,0x08,BIT,0},//; sharp_k_val     
  {0xfd,0x01,BIT,0},//
  {0xd1,0x20,BIT,0},//;skin_sharp_delta
  {0xfd,0x02,BIT,0},//;
  {0xdc,0x05,BIT,0},//;肤色降锐化 skin_sharp_sel
  {0x05,0x20,BIT,0},//;排除肤色降`锐化对分辨率卡引起的干扰
  {0xfd,0x02,BIT,0},//
  {0x81,0x00,BIT,0},//;bpc_ratio_vt
  {0xfd,0x01,BIT,0},//;
  {0xfc,0x00,BIT,0},//;bpc_median_en
  {0x7d,0x05,BIT,0},//;bpc_med_thr
  {0x7e,0x05,BIT,0},//;
  {0x7f,0x09,BIT,0},//;
  {0x80,0x08,BIT,0},//;
  {0xfd,0x02,BIT,0},// 
  {0xdd,0x0f,BIT,0},//;enable
  {0xfd,0x01,BIT,0},//;沿方向边缘平滑阈值，越小越弱 
  {0x6d,0x08,BIT,0},//;dns_flat_dif 强平滑（平坦）区域平滑阈值  0x81↓
  {0x6e,0x08,BIT,0},//;
  {0x6f,0x10,BIT,0},//;
  {0x70,0x18,BIT,0},//;
  {0x86,0x18,BIT,0},//;dark
  {0x71,0x0a,BIT,0},//;dns_edge_dif 弱轮廓（非平坦）区域平滑阈值	 0x81↑
  {0x72,0x0a,BIT,0},//;
  {0x73,0x14,BIT,0},//;
  {0x74,0x14,BIT,0},//;  
  {0x75,0x08,BIT,0},//;dns_edge_gdif
  {0x76,0x0a,BIT,0},//;
  {0x77,0x06,BIT,0},//;
  {0x78,0x06,BIT,0},//;
  {0x79,0x25,BIT,0},//;{raw_flat_fac, raw_edge_fac}  
  {0x7a,0x23,BIT,0},//;
  {0x7b,0x22,BIT,0},//;
  {0x7c,0x0 ,BIT,0},//
  {0x81,0x0d,BIT,0},//;2x;dns_flat_thr 根据增益判定区域阈值
  {0x82,0x18,BIT,0},//;4x
  {0x83,0x20,BIT,0},//;8x
  {0x84,0x24,BIT,0},//;16x
  {0xfd,0x02,BIT,0},//;dem  
  {0x83,0x12,BIT,0},//;{dem_morie_thr, dem_hfmax_thr}
  {0x84,0x14,BIT,0},//;dem_grad_thr 
  {0x86,0x04,BIT,0},//;dem_grad_dif
  {0xfd,0x01,BIT,0},//;pf
  {0x61,0x60,BIT,0},//;
  {0x62,0x28,BIT,0},//;
  {0x8a,0x10,BIT,0},//; 
  {0xfd,0x01,BIT,0},//;gamma  
  {0x8b,0x00,BIT,0},//;00  00
  {0x8c,0x09,BIT,0},//;0e  09
  {0x8d,0x17,BIT,0},//;1a  13
  {0x8e,0x22,BIT,0},//;2b  1b
  {0x8f,0x2e,BIT,0},//;38  23
  {0x90,0x42,BIT,0},//;4e  32
  {0x91,0x53,BIT,0},//;5f  41
  {0x92,0x5f,BIT,0},//;6e  4d
  {0x93,0x6d,BIT,0},//;7a  5c
  {0x94,0x84,BIT,0},//;8e  70
  {0x95,0x95,BIT,0},//;9d  84
  {0x96,0xa5,BIT,0},//;aa  94
  {0x97,0xb3,BIT,0},//;b6  a3
  {0x98,0xc0,BIT,0},//;c0  b5
  {0x99,0xcc,BIT,0},//;c9  c2
  {0x9a,0xd6,BIT,0},//;d3  cf
  {0x9b,0xdf,BIT,0},//;dc  d9
  {0x9c,0xe7,BIT,0},//;e4  e3
  {0x9d,0xee,BIT,0},//;eb  ec
  {0x9e,0xf4,BIT,0},//;f3  f4
  {0x9f,0xfa,BIT,0},//;fa  fa
  {0xa0,0xff,BIT,0},//;ff  ff
  {0xfd,0x02,BIT,0},//;CCM
  {0x15,0xc0,BIT,0},//;d4;b>th
  {0x16,0x8c,BIT,0},//;a1;r<th  
  {0xa0,0x86,BIT,0},//;a6;(红色接近，肤色不理想)   ;!F
  {0xa1,0xfa,BIT,0},//;f4;
  {0xa2,0x00,BIT,0},//;e6;
  {0xa3,0xdb,BIT,0},//;f4;
  {0xa4,0xc0,BIT,0},//;ac;
  {0xa5,0xe6,BIT,0},//;e0;
  {0xa6,0xed,BIT,0},//;ed;
  {0xa7,0xda,BIT,0},//;cd;
  {0xa8,0xb9,BIT,0},//;c6;
  {0xa9,0x0c,BIT,0},//;3c;
  {0xaa,0x33,BIT,0},//;33;
  {0xab,0x0f,BIT,0},//;0f;        
  {0xac,0x93,BIT,0},//;a6;F
  {0xad,0xe7,BIT,0},//;da
  {0xae,0x06,BIT,0},//;00
  {0xaf,0xda,BIT,0},//;c7
  {0xb0,0xcc,BIT,0},//;cc
  {0xb1,0xda,BIT,0},//;ed
  {0xb2,0xda,BIT,0},//;c7
  {0xb3,0xda,BIT,0},//;d4
  {0xb4,0xcc,BIT,0},//;e6
  {0xb5,0x0c,BIT,0},//;0c
  {0xb6,0x33,BIT,0},//;33
  {0xb7,0x0f,BIT,0},//;0f
  {0xfd,0x01,BIT,0},//;sat u 
  {0xd3,0x66,BIT,0},//;
  {0xd4,0x6a,BIT,0},//;
  {0xd5,0x56,BIT,0},//;
  {0xd6,0x44,BIT,0},//;
  {0xd7,0x66,BIT,0},//;     
  {0xd8,0x6a,BIT,0},//;
  {0xd9,0x56,BIT,0},//;
  {0xda,0x44,BIT,0},//;
  {0xfd,0x01,BIT,0},//;auto_sat
  {0xdd,0x30,BIT,0},//;
  {0xde,0x10,BIT,0},//;
  {0xdf,0xff,BIT,0},//;a0;y_mean_th
  {0x00,0x00,BIT,0},//;status
  {0xfd,0x01,BIT,0},//;白色物体表面有彩色噪声降低此值;uv_th
  {0xc2,0xaa,BIT,0},//;
  {0xc3,0x88,BIT,0},//;
  {0xc4,0x77,BIT,0},//;
  {0xc5,0x66,BIT,0},//;
  {0xfd,0x01,BIT,0},//
  {0xcd,0x10,BIT,0},//;
  {0xce,0x1f,BIT,0},//;
  {0xcf,0x30,BIT,0},//;
  {0xd0,0x45,BIT,0},//;
  {0xfd,0x02,BIT,0},//;low_lum_offset
  {0x31,0x60,BIT,0},//;
  {0x32,0x60,BIT,0},//;
  {0x33,0xc0,BIT,0},//;
  {0x35,0x60,BIT,0},//;
  {0x37,0x13,BIT,0},//;
  {0xfd,0x01,BIT,0},//;heq                         
  {0x0e,0x80,BIT,0},//;      
  {0x0f,0x20,BIT,0},//;k_max
  {0x10,0x80,BIT,0},//;ku_outdoor
  {0x11,0x80,BIT,0},//;ku_nr
  {0x12,0x80,BIT,0},//;ku_dummy
  {0x13,0x80,BIT,0},//;ku_low
  {0x14,0x88,BIT,0},//;kl_outdoor 
  {0x15,0x88,BIT,0},//;kl_nr      
  {0x16,0x88,BIT,0},//;kl_dummy    
  {0x17,0x88,BIT,0},//;kl_low        
  {0xfd,0x00,BIT,0},//;
  {0x31,0x06,BIT,0},//;
  {0xfd,0x01,BIT,0},//;auto   
  {0x32,0x15,BIT,0},//;
  {0x33,0xef,BIT,0},//;
  {0x34,0x07,BIT,0},//;
  {0xd2,0x01,BIT,0},//;{contrast sat}
  {0xfb,0x25,BIT,0},//;
  {0xf2,0x49,BIT,0},//;
  {0x35,0x40,BIT,0},//
  {0x5d,0x11,BIT,0},//; 
  {0xfd,0x00,BIT,0},//;out en
  {0x92,0x01,BIT,0},//
  {0xfd,0x01,BIT,0},//
  {0x36,0x00,BIT,0},//
  
     

};

static const struct sensor_reg_list sp0a20_init = {
	.size = ARRAY_ROW(init_sp0a20),
	.val = init_sp0a20
};

static const struct sensor_reg_list sp0a20_vga = {
	.size = ARRAY_ROW(vga_sp0a20),
	.val = vga_sp0a20
};
static const struct sensor_reg_list sp0a20_qvga = {
	.size = ARRAY_ROW(qvga_sp0a20),
	.val = qvga_sp0a20
};
static const struct sensor_reg_list sp0a20_qcif = {
	.size = ARRAY_ROW(qcif_sp0a20),
	.val = qcif_sp0a20
};
static const struct sensor_reg_list sp0a20_qqvga = {
	.size = ARRAY_ROW(qqvga_sp0a20),
	.val = qqvga_sp0a20
};
static const struct sensor_win_size sp0a20_win_size[] = {
	WIN_SIZE("VGA", W_VGA, H_VGA, &sp0a20_vga),
	WIN_SIZE("QVGA", W_QVGA, H_QVGA, &sp0a20_qvga),
	WIN_SIZE("QCIF", W_QCIF, H_QCIF, &sp0a20_qcif),
	WIN_SIZE("QQVGA", W_QQVGA, H_QQVGA, &sp0a20_qqvga),
};

static const struct sensor_win_cfg sp0a20_win_cfg = {
	.num = ARRAY_ROW(sp0a20_win_size),
	.win_size = sp0a20_win_size
};

static const struct sensor_csi_cfg sp0a20_csi_cfg = {
	.csi_en = true,
	.d_term_en = 5,
	.c_term_en = 5,
	.dhs_settle = 5,
	.chs_settle = 5,
};

static const struct sensor_info sp0a20_info = {
	.name		= "sp0a20_csi",
	.chip_id	= 0x2B,
	.mclk		= 26,
	.i2c_addr	= 0x21,
	.exp_def	= 0,
	.awb_def	= 1,
	.rst_act_h	= false,
	.pdn_act_h	= true,
	.init		= &sp0a20_init,
	.win_cfg	= &sp0a20_win_cfg,
	.csi_cfg	= &sp0a20_csi_cfg
};

extern void sensor_power_down(bool high, bool acth, int id);
extern void sensor_reset(bool rst, bool acth);
extern void sensor_clock(bool out, int mclk);
extern void sensor_read(const u16 addr, u8 *data, u8 bits);
extern void sensor_write(const u16 addr, const u8 data, u8 bits);
extern void sensor_write_group(struct sensor_reg* reg, u32 size);

static u32 sp0a20_power(int id, int mclk, bool rst_h, bool pdn_h)
{
	/* set state to power off */
	sensor_power_down(true, pdn_h, 0);
	mdelay(10);
	sensor_power_down(true, pdn_h, 1);
	mdelay(20);
	sensor_reset(true, rst_h);
	mdelay(10);
	sensor_clock(false, mclk);
	mdelay(5);

	/* power on sequence */
	sensor_clock(true, mclk);
	mdelay(10);
	sensor_power_down(false, pdn_h, id);
	mdelay(5);

	sensor_power_down(true, pdn_h, id);
	mdelay(5);
	sensor_power_down(false, pdn_h, id);
	mdelay(5);

	sensor_reset(true, rst_h);
	mdelay(5);
	sensor_reset(false, rst_h);
	mdelay(400);

	return 0;
}

static u32 sp0a20_get_chipid(void)
{
	u32 chip_id = 0;

	sensor_write(0xfd, 0x00, BIT);
	mdelay(10);
	sensor_read(0x02, &chip_id, BIT);
	rda_dbg_camera("%s: chip_id = %x\n", __func__,chip_id);

	return chip_id;
}

static u32 sp0a20_get_lum(void)
{
	u8 val = 0;
	u32 ret = 0;

	sensor_write(0xfd, 0x00, BIT);
	sensor_read(0x23, &val, BIT);
	sensor_write(0xfd, 0x00, BIT);

	if (val > 0x50)
		ret = 1;

	return ret;
}



#define SP0A20_FLIP_BASE	0x3F
#define SP0A20_H_FLIP_BIT	0
#define SP0A20_V_FLIP_BIT		1
static void sp0a20_set_flip(int hv, int flip)
{
	u8 tmp = 0;

	sensor_read(SP0A20_FLIP_BASE, &tmp, BIT);

	if (hv) {
		if (flip)
			tmp |= (0x1 << SP0A20_V_FLIP_BIT);
		else
			tmp &= ~(0x1 << SP0A20_V_FLIP_BIT);
	}
	else {
		if (flip)
			tmp |= (0x1 << SP0A20_H_FLIP_BIT);
		else
			tmp &= ~(0x1 << SP0A20_H_FLIP_BIT);
	}

	sensor_write(0xfd, 0x01, BIT);
	sensor_write(SP0A20_FLIP_BASE, tmp, BIT);
	sensor_write(0xfd, 0x00, BIT);
}



/*
#define SP0A20_EXP_ROW		ARRAY_ROW(exp_sp0a20)
#define SP0A20_EXP_COL		ARRAY_COL(exp_sp0a20)
static void sp0a20_set_exp(int exp)
{
	return; // need to be done by ISP
	int key = exp + (SP0A20_EXP_ROW / 2);
	if ((key < 0) || (key > (SP0A20_EXP_ROW - 1)))
		return;

	sensor_write_group(exp_sp0a20[key], SP0A20_EXP_COL);
}
*/
#define SP0A20_AWB_ROW		ARRAY_ROW(awb_sp0a20)
#define SP0A20_AWB_COL		ARRAY_COL(awb_sp0a20)
static void sp0a20_set_awb(int awb)
{
	return; // need to be done by ISP
	if ((awb < 0) || (awb > (SP0A20_AWB_ROW - 1)))
		return;

	sensor_write_group(awb_sp0a20[awb], SP0A20_AWB_COL);
}

static struct sensor_ops sp0a20_ops = {
	.power		= sp0a20_power,
	.get_chipid	= sp0a20_get_chipid,
	.get_lum	= sp0a20_get_lum,
	.set_flip	= NULL,//sp0a20_set_flip,
	.set_exp	= NULL, //sp0a20_set_exp,
	.set_awb	= NULL,//sp0a20_set_awb,
	.start		= NULL,
	.stop		= NULL
};

struct sensor_dev sp0a20_dev = {
	.info	= &sp0a20_info,
	.ops	= &sp0a20_ops,
};

#undef BIT
#endif
