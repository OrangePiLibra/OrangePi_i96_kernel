#include <linux/module.h>
#include <linux/init.h>
#include <linux/interrupt.h>
#include <linux/input.h>
#include <linux/platform_device.h>
#include <linux/gpio.h>
#include <linux/slab.h>
#include <linux/wakelock.h>
#include <asm/irq.h>
#include <asm/io.h>
#include <linux/irq.h>
#include <linux/delay.h>

#include <mach/hardware.h>
#include <mach/irqs.h>
#include <plat/devices.h>
#include <plat/reg_keypad.h>
#include <plat/rda_debug.h>
#include <plat/boot_mode.h>

enum rda_key_irqs {
	POWER = 0,
	VOLUME_UP,
	VOLUME_DOWN
};

#define KEYPAD_PWRKEY_JITTER 50 //50ms to avoid pwrkey jitter
#define KEYPAD_VOLUME_JITTER 20 //20ms to avoid volume key jitter

static unsigned int rda_vol_jitter = KEYPAD_VOLUME_JITTER;

struct rda_kp_dev {
	struct device		*dev;
	void __iomem		*base;		/* virtual */

	struct rda_keypad_device_data *pconfig;

	struct input_dev *input;
	struct timer_list timer;

	spinlock_t lock;

	int irq[3];
	uint64_t pre_key_matrix;
	int pre_key_on;

	int suspend;
	int volumeup_irq;
	int volumedown_irq;
	struct work_struct kp_up_work;
	struct work_struct kp_down_work;
	struct work_struct kp_pwrkey_work;
};


static struct workqueue_struct *kp_wq;

//use sysfs to change vol key jitter time from shell
//for debug use
static ssize_t rda_vol_show(struct kobject *kobj,
		struct kobj_attribute *attr, char *buf)
{
	return sprintf(buf, "0x%x\n", rda_vol_jitter);
}

static ssize_t rda_vol_store(struct kobject *kobj,
		struct kobj_attribute *attr, const char *buf, size_t n)
{
	unsigned int value;
	if (sscanf(buf, "%x", &value) != 1)
		return -EINVAL;
	rda_vol_jitter = value;
	return n;
}
static struct kobj_attribute rda_vol_attr =
		__ATTR(rda_vol_jitter, 0664, rda_vol_show, rda_vol_store);

static int __init rda_vol_init_sysfs(void)
{
	int error = 0;
	error = sysfs_create_file(kernel_kobj, &rda_vol_attr.attr);
	if (error)
		printk(KERN_ERR "sysfs_create_file failed: %d\n", error);
	return error;
}
//end of sysfs

#ifdef HAS_MATRIX
static void rda_key_scan(struct rda_kp_dev *rda_kp, uint64_t *key)
{
	HWP_KEYPAD_T* hwp_keypad = (HWP_KEYPAD_T*)rda_kp->base;

	*key = GET_BITFIELD(hwp_keypad->KP_DATA_L, KEYPAD_KP_DATA_L);
	*key |= ((uint64_t)(GET_BITFIELD(hwp_keypad->KP_DATA_H, KEYPAD_KP_DATA_H))<<32);
}
#endif /* HAS_MATRIX */

static void rda_key_irq_clear(struct rda_kp_dev *rda_kp)
{
	HWP_KEYPAD_T* hwp_keypad = (HWP_KEYPAD_T*)rda_kp->base;

	hwp_keypad->KP_IRQ_CLR = KEYPAD_KP_IRQ_CLR;
}

static void rda_key_irq_enable(struct rda_kp_dev *rda_kp)
{
	HWP_KEYPAD_T* hwp_keypad = (HWP_KEYPAD_T*)rda_kp->base;

	hwp_keypad->KP_IRQ_MASK = KEYPAD_KP_EVT0_IRQ_MASK
				     | KEYPAD_KP_EVT1_IRQ_MASK;

	if (rda_get_boot_mode() == BM_CHARGER)
		hwp_keypad->KP_IRQ_MASK |= KEYPAD_KP_ITV_IRQ_MASK;
}

static void rda_key_irq_disable(struct rda_kp_dev *rda_kp)
{
	HWP_KEYPAD_T* hwp_keypad = (HWP_KEYPAD_T*)rda_kp->base;

	hwp_keypad->KP_IRQ_MASK = 0;
}

static u32 rda_key_get_irq_status(struct rda_kp_dev *rda_kp)
{
	HWP_KEYPAD_T* hwp_keypad = (HWP_KEYPAD_T*)rda_kp->base;
	u32 mask = KEYPAD_KP_EVT0_IRQ_STATUS | KEYPAD_KP_EVT1_IRQ_STATUS;
	u32 status;

	if (rda_get_boot_mode() == BM_CHARGER)
		mask |= KEYPAD_KP_ITV_IRQ_STATUS;

	status = hwp_keypad->KP_IRQ_CAUSE & mask;

	return status;
}

static int rda_key_open(struct input_dev *dev)
{
	struct rda_kp_dev *rda_kp = input_get_drvdata(dev);
	HWP_KEYPAD_T* hwp_keypad = (HWP_KEYPAD_T*)rda_kp->base;
	struct rda_keypad_device_data *pconfig = rda_kp->pconfig;
	u32 key_dbn_time;
	u32 key_itv_time;
	u32 key_out_mask = 0x1;
	u32 key_in_mask = 0;
	u32 key_cnt = 0;
	u32 temp;

	temp = key_out_mask;
	/* Find out how many lines we are using. */
	while (temp) {
		++key_cnt;
		temp = temp >> 1;
	}

	if ((pconfig->dbn_time >= (5 + 1) * key_cnt) &&
			(pconfig->dbn_time <= 1280 * key_cnt)) {
		key_dbn_time = (pconfig->dbn_time / (5 * key_cnt)) - 1;
	} else if (pconfig->dbn_time >= 2) {
		key_dbn_time = pconfig->dbn_time - 1;
	} else {
		key_dbn_time = 1;
	}

	if (pconfig->rows && pconfig->cols) {
		/* key_out_mask and key_in_mask should be generated by rows and cols.*/
	}

	/* enable keypad module and key IRQ */
	hwp_keypad->KP_CTRL = KEYPAD_KP_EN
		| KEYPAD_KP_DBN_TIME(key_dbn_time)
		| KEYPAD_KP_IN_MASK(key_in_mask)
		| KEYPAD_KP_OUT_MASK(key_out_mask);

	if (rda_get_boot_mode() == BM_CHARGER) {
		/* Enable interval irq in charger mode. */
		key_itv_time = pconfig->itv_time;
		hwp_keypad->KP_CTRL |= KEYPAD_KP_ITV_TIME(key_itv_time);
	}

	/* clear current IRQ */
	rda_key_irq_clear(rda_kp);
	rda_key_irq_enable(rda_kp);
	enable_irq(rda_kp->irq[POWER]);

	enable_irq(rda_kp->irq[VOLUME_UP]);
	enable_irq(rda_kp->irq[VOLUME_DOWN]);

	return 0;
}

static void rda_key_close(struct input_dev *dev)
{
	struct rda_kp_dev *rda_kp = input_get_drvdata(dev);
	HWP_KEYPAD_T* hwp_keypad = (HWP_KEYPAD_T*)rda_kp->base;

	hwp_keypad->KP_CTRL = 0;
	rda_key_irq_clear(rda_kp);
	rda_key_irq_disable(rda_kp);

	disable_irq(rda_kp->irq[VOLUME_DOWN]);
	disable_irq(rda_kp->irq[VOLUME_UP]);
}

static void rda_kp_pwrkey_work(struct work_struct *work)
{
	struct rda_kp_dev *rda_kp = container_of(work, struct rda_kp_dev, kp_pwrkey_work);
	HWP_KEYPAD_T* hwp_keypad = (HWP_KEYPAD_T*)rda_kp->base;
	u32 status;
#ifdef HAS_MATRIX
	uint64_t keystate;
	uint64_t changed;
	int idx;
#else
	unsigned int changed;
#endif /* HAS_MATRIX */
	int key_down = 0;
	int sync_me = 0;
	int key_reset = 0;

	status = rda_key_get_irq_status(rda_kp);
	rda_key_irq_clear(rda_kp);

	rda_dbg_keypad("%s, status = 0x%08x\n", __func__, status);

	if (status) {
#ifdef HAS_MATRIX
		rda_key_scan(rda_kp, &keystate);
		rda_dbg_keypad("rda_kp_tasklet, keystate = 0x%llx\n", keystate);
		changed = keystate ^ rda_kp->pre_key_matrix;
		rda_kp->pre_key_matrix = keystate;
		key_down = keystate ? 1 : 0;
		if (changed) {
			for (idx = find_first_bit((unsigned long *)&changed, KEYPAD_MAX_NUMBER);
				idx < KEYPAD_MAX_NUMBER;
				idx = find_next_bit((unsigned long *)&changed, KEYPAD_MAX_NUMBER, idx+1)) {
				if (keystate & (1<<idx)) {
					rda_dbg_keypad("key %d pressed\n", idx);
					input_report_key(rda_kp->input, idx, 1);
					sync_me = 1;
				} else {
					rda_dbg_keypad("key %d released\n", idx);
					input_report_key(rda_kp->input, idx, 0);
					sync_me = 1;
				}
			}
		}
#endif /* HAS_MATRIX */

		key_reset = hwp_keypad->KP_STATUS & KEYPAD_KP_ON;
		changed = key_reset ^ rda_kp->pre_key_on;
		if (!changed && !key_reset && rda_kp->suspend) {
			input_report_key(rda_kp->input, KEY_POWER, 1);
			input_report_key(rda_kp->input, KEY_POWER, 0);
#if 0
			pr_debug("%s:keypad up event come when suspend, fake down and up to app\n", __func__);
#else
			pr_info("**** %s:keypad up event come when suspend, fake down and up to app\n", __func__);
#endif /* #if 0 */
			sync_me = 1;
		}
		else if (changed || (status & KEYPAD_KP_ITV_IRQ_STATUS)) {
			rda_kp->pre_key_on = key_reset;
			key_down = key_reset ? 1 : 0;

			input_report_key(rda_kp->input, KEY_POWER, key_down);
#if 1
			rda_dbg_keypad("key code is %d,value is %d\n", KEY_POWER, key_down);
#else
			pr_info("====> key = %d, value = %d\n", KEY_POWER, key_down);
#endif /* #if 0 */
			sync_me = 1;
		}
	}

	if (sync_me)
		input_sync(rda_kp->input);

	msleep(KEYPAD_PWRKEY_JITTER);
	rda_key_irq_enable(rda_kp);
}

static void rda_kpup_work(struct work_struct *work)
{
	struct rda_kp_dev *rda_kp = container_of(work,struct rda_kp_dev,kp_up_work);
	int gpio_value = 0;
	if (rda_kp->volumeup_irq) {
		gpio_value = gpio_get_value(rda_kp->pconfig->gpio_volume_up);
		rda_dbg_keypad("key code is %d, the gpio value is %d\n",
				KEY_VOLUMEUP, gpio_value);
		input_report_key(rda_kp->input, KEY_VOLUMEUP, gpio_value);
		input_sync(rda_kp->input);

		if (gpio_value == 1) {
			irq_set_irq_type(rda_kp->irq[VOLUME_UP],IRQ_TYPE_LEVEL_LOW);
		} else if (gpio_value == 0) {
			irq_set_irq_type(rda_kp->irq[VOLUME_UP],IRQ_TYPE_LEVEL_HIGH);
		}
		rda_kp->volumeup_irq = 0;
		//msleep(KEYPAD_VOLUME_JITTER);
		msleep(rda_vol_jitter);
		enable_irq(rda_kp->irq[VOLUME_UP]);
		rda_dbg_keypad("enable VOLUME_UP %d\n",rda_vol_jitter);
	}
}

static void rda_kpdown_work(struct work_struct *work)
{
	struct rda_kp_dev *rda_kp = container_of(work,struct rda_kp_dev,kp_down_work);
	int gpio_value = 0;
	if (rda_kp->volumedown_irq) {
		gpio_value = gpio_get_value(rda_kp->pconfig->gpio_volume_down);
		rda_dbg_keypad("key code is %d, the gpio value is %d\n",
				KEY_VOLUMEDOWN, gpio_value);
		input_report_key(rda_kp->input, KEY_VOLUMEDOWN, gpio_value);
		input_sync(rda_kp->input);
		if (gpio_value == 1)
			irq_set_irq_type(rda_kp->irq[VOLUME_DOWN],IRQ_TYPE_LEVEL_LOW);
		else if (gpio_value == 0)
			irq_set_irq_type(rda_kp->irq[VOLUME_DOWN],IRQ_TYPE_LEVEL_HIGH);
		rda_kp->volumedown_irq = 0;
		//msleep(KEYPAD_VOLUME_JITTER);
		msleep(rda_vol_jitter);
		enable_irq(rda_kp->irq[VOLUME_DOWN]);
		rda_dbg_keypad("enable VOLUME_DOWN %d\n",rda_vol_jitter);
	}
}

static irqreturn_t rda_kpup_interrupt(int irq, void *dev_id)
{
	struct rda_kp_dev *rda_kp = dev_id;
	unsigned long flags;
	spin_lock_irqsave(&rda_kp->lock, flags);
	if (irq == rda_kp->irq[VOLUME_UP]) {
		rda_kp->volumeup_irq = 1;
		disable_irq_nosync(rda_kp->irq[VOLUME_UP]);
		rda_dbg_keypad("VOLUME_UP IRQ\n");
		queue_work(kp_wq,&rda_kp->kp_up_work);
	}
	spin_unlock_irqrestore(&rda_kp->lock, flags);
	pm_wakeup_event(rda_kp->dev, 500);
	return IRQ_HANDLED;
}

static irqreturn_t rda_kpdown_interrupt(int irq, void *dev_id)
{
	struct rda_kp_dev *rda_kp = dev_id;
	unsigned long flags;
	spin_lock_irqsave(&rda_kp->lock, flags);
	if (irq == rda_kp->irq[VOLUME_DOWN]) {
		rda_kp->volumedown_irq = 1;
		disable_irq_nosync(rda_kp->irq[VOLUME_DOWN]);
		rda_dbg_keypad("VOLUME_DOWN IRQ\n");
		queue_work(kp_wq,&rda_kp->kp_down_work);
	}
	spin_unlock_irqrestore(&rda_kp->lock, flags);
	pm_wakeup_event(rda_kp->dev, 500);
	return IRQ_HANDLED;
}

static irqreturn_t rda_kp_interrupt(int irq, void *dev_id)
{
	struct rda_kp_dev *rda_kp = dev_id;
	unsigned long flags;

	spin_lock_irqsave(&rda_kp->lock, flags);

	/* disable interrupt */
	if (irq == rda_kp->irq[POWER]) {
		rda_key_irq_disable(rda_kp);
		rda_dbg_keypad("rda_kp_interrupt0\n");

		queue_work(kp_wq,&rda_kp->kp_pwrkey_work);
		//rda_kp_handle_keys(rda_kp);

		//rda_key_irq_enable(rda_kp);

	}

	spin_unlock_irqrestore(&rda_kp->lock, flags);
	pm_wakeup_event(rda_kp->dev, 500);

	return IRQ_HANDLED;
}

static DEFINE_MUTEX(kp_enable_mutex);
static int kp_enable = 1;

static ssize_t rda_kp_enable_show(struct device *dev,
				   struct device_attribute *attr, char *buf)
{
	return sprintf(buf, "%u\n", kp_enable);
}

static ssize_t rda_kp_enable_store(struct device *dev, struct device_attribute *attr,
					const char *buf, size_t count)
{
	struct platform_device *pdev = to_platform_device(dev);
	struct rda_kp_dev *rda_kp = platform_get_drvdata(pdev);
	int state;

	if (sscanf(buf, "%u", &state) != 1)
		return -EINVAL;

	if ((state != 1) && (state != 0))
		return -EINVAL;

	mutex_lock(&kp_enable_mutex);
	if (state != kp_enable) {
		if (state)
			rda_key_irq_enable(rda_kp);
		else
			rda_key_irq_disable(rda_kp);
		kp_enable = state;
	}
	mutex_unlock(&kp_enable_mutex);

	return strnlen(buf, count);
}

static DEVICE_ATTR(enable, S_IRUGO | S_IWUSR, rda_kp_enable_show, rda_kp_enable_store);

#ifdef CONFIG_PM
static int rda_kp_suspend(struct device *dev)
{
	struct rda_kp_dev *rda_kp = NULL;
	if(!dev)
		return 0;

	rda_kp = dev_get_drvdata(dev);
	if(!rda_kp)
		return 0;

	rda_kp->suspend = 1;

	return 0;
}

static int rda_kp_resume(struct device *dev)
{
	struct rda_kp_dev *rda_kp = NULL;
	if(!dev)
		return 0;

	rda_kp = dev_get_drvdata(dev);
	if(!rda_kp)
		return 0;

	rda_kp->suspend = 0;

	return 0;
}
#else
#define rda_kp_suspend	NULL
#define rda_kp_resume	NULL
#endif

static int rda_kp_probe(struct platform_device *pdev)
{
	struct rda_kp_dev *rda_kp;
	struct input_dev *input_dev;
	struct rda_keypad_device_data *pdata = pdev->dev.platform_data;
	struct resource *res;
	int ret = 0, i;
	int irq_request_num = 0;

	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
	if (!res) {
		return -ENXIO;
	}

	rda_kp = kzalloc(sizeof(struct rda_kp_dev), GFP_KERNEL);
	if (!rda_kp) {
		dev_err(&pdev->dev, "rda_kp alloc fail\n");
		return -ENOMEM;
	}

	rda_kp->suspend = 0;
	rda_kp->pconfig = pdata;

	gpio_request(rda_kp->pconfig->gpio_volume_up, "volume_up");
	gpio_direction_input(rda_kp->pconfig->gpio_volume_up);
	gpio_set_debounce(rda_kp->pconfig->gpio_volume_up,20);

	gpio_request(rda_kp->pconfig->gpio_volume_down, "volume_down");
	gpio_direction_input(rda_kp->pconfig->gpio_volume_down);
	gpio_set_debounce(rda_kp->pconfig->gpio_volume_down,20);

	input_dev = input_allocate_device();
	if (!input_dev) {
		dev_err(&pdev->dev, "input_allocate_device fail\n");
		ret = -ENOMEM;
		goto alloc_err;
	}

	rda_kp->input = input_dev;
	rda_kp->dev = &pdev->dev;

	rda_kp->base = ioremap(res->start, resource_size(res));
	if (!rda_kp->base) {
		dev_err(&pdev->dev, "ioremap fail\n");
		ret = -ENOMEM;
		goto iomap_err;
	}

	ret = device_create_file(&pdev->dev, &dev_attr_enable);
	if (ret) {
		dev_err(&pdev->dev, "device_create_file fail\n");
		goto dev_file_err;
	}

	/* setup input device */
	set_bit(EV_KEY, input_dev->evbit);
	//set_bit(EV_REP, input_dev->evbit);

	for (i = 0; i < (KEYPAD_MAX_NUMBER); i++) {
		set_bit(i & KEY_MAX, input_dev->keybit);
	}
	set_bit(KEY_VOLUMEDOWN, input_dev->keybit);
	set_bit(KEY_VOLUMEUP, input_dev->keybit);
	set_bit(KEY_POWER, input_dev->keybit);

	input_dev->open = rda_key_open;
	input_dev->close = rda_key_close;
	input_dev->name = pdev->name;
	input_dev->phys = "rda-keypad/input0";
	input_dev->dev.parent = &pdev->dev;
	input_dev->id.version = 0x0100;
	input_dev->id.bustype = BUS_HOST;

	input_set_drvdata(input_dev, rda_kp);

	spin_lock_init(&rda_kp->lock);

	rda_kp->irq[POWER] = platform_get_irq(pdev, 0);
	set_irq_flags(rda_kp->irq[POWER], IRQF_VALID | IRQF_NOAUTOEN);
	if (rda_kp->irq[POWER] > 0) {
		ret = request_irq(rda_kp->irq[POWER], rda_kp_interrupt,
				IRQF_NO_SUSPEND, "rda-pwrkey", rda_kp);
		if (ret < 0) {
			dev_err(&pdev->dev, "Invalid irq of power-on\n");
			goto irq_err;
		}
		irq_request_num++;
	}

	rda_kp->irq[VOLUME_UP] = gpio_to_irq(rda_kp->pconfig->gpio_volume_up);
	set_irq_flags(rda_kp->irq[VOLUME_UP], IRQF_VALID | IRQF_NOAUTOEN);
	if (rda_kp->irq[VOLUME_UP] > 0) {
		ret = request_irq(rda_kp->irq[VOLUME_UP], rda_kpup_interrupt,
			IRQ_TYPE_LEVEL_HIGH | IRQF_NO_SUSPEND,
			"rda-vupkey", rda_kp);
		if (ret < 0) {
			dev_err(&pdev->dev, "Invalid irq of volumn-up\n");
			goto irq_err;
		}
		irq_request_num++;
	}

	rda_kp->irq[VOLUME_DOWN] = gpio_to_irq(rda_kp->pconfig->gpio_volume_down);
	set_irq_flags(rda_kp->irq[VOLUME_DOWN], IRQF_VALID | IRQF_NOAUTOEN);
	if (rda_kp->irq[VOLUME_DOWN] > 0) {
		ret = request_irq(rda_kp->irq[VOLUME_DOWN], rda_kpdown_interrupt,
			IRQ_TYPE_LEVEL_HIGH  | IRQF_NO_SUSPEND,
			"rda-vdownkey", rda_kp);
		if (ret < 0) {
			dev_err(&pdev->dev, "Invalid irq of volumn-down\n");
			goto irq_err;
		}
		irq_request_num++;
	}

	kp_wq = create_singlethread_workqueue("kp_wq");
	INIT_WORK(&rda_kp->kp_up_work,rda_kpup_work);
	INIT_WORK(&rda_kp->kp_down_work,rda_kpdown_work);
	INIT_WORK(&rda_kp->kp_pwrkey_work,rda_kp_pwrkey_work);
	/*
	 * After we initialize irqs, we can register input device.
	 * Input framework will call open dev callback which enables irqs.
	 * */
	ret = input_register_device(rda_kp->input);
	if (ret) {
		dev_err(&pdev->dev, "fail to register rda-keypad input device\n");
		goto reg_err;
	}

	platform_set_drvdata(pdev, rda_kp);

	device_init_wakeup(&pdev->dev, 1);

	dev_info(&pdev->dev, "rda-keypad enabled\n");

	return 0;

reg_err:
irq_err:
	for (i = 0; i < irq_request_num; i++) {
		if (rda_kp->irq[i]) {
			disable_irq(rda_kp->irq[i]);
			free_irq(rda_kp->irq[i], rda_kp);
		}
	}
	device_remove_file(&pdev->dev, &dev_attr_enable);

dev_file_err:
	iounmap(rda_kp->base);

iomap_err:
	input_free_device(rda_kp->input);

alloc_err:
	kfree(rda_kp);

	return ret;
}

static int rda_kp_remove(struct platform_device *pdev)
{
	struct rda_kp_dev *rda_kp = platform_get_drvdata(pdev);
	int i;

	rda_key_close(rda_kp->input);
	for (i = 0; i < 3; i++) {
		disable_irq(rda_kp->irq[i]);
		free_irq(rda_kp->irq[i], rda_kp);
	}
	destroy_workqueue(kp_wq);
	input_unregister_device(rda_kp->input);
	device_remove_file(&pdev->dev, &dev_attr_enable);
	input_free_device(rda_kp->input);
	kfree(rda_kp);

	return 0;
}

static SIMPLE_DEV_PM_OPS(rda_kp_pm_ops, rda_kp_suspend, rda_kp_resume);

static struct platform_driver rda_kp_driver = {
	.probe		= rda_kp_probe,
	.remove		= rda_kp_remove,
	.driver		= {
		.name	= RDA_KEYPAD_DRV_NAME,
		.owner	= THIS_MODULE,
		.pm	= &rda_kp_pm_ops,
	},
};

static int __init rda_kp_init(void)
{
	rda_vol_init_sysfs();
	return platform_driver_register(&rda_kp_driver);
}

static void __exit rda_kp_exit(void)
{
	platform_driver_unregister(&rda_kp_driver);
}

module_init(rda_kp_init);
module_exit(rda_kp_exit);

MODULE_DESCRIPTION("RDA Keypad Driver");
MODULE_LICENSE("GPL");
MODULE_ALIAS("platform:rda_keypad");
